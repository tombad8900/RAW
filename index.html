<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>WAR-CORE V20 [Ultima]</title>
  <meta id="meta-desc" name="description" content="Secure Data Matrix - Loading Payload..." />
  <meta property="og:title" content="WAR-CORE V20 [Ultima]" />
  <meta id="og-desc" property="og:description" content="Secure Data Matrix - Loading Payload..." />
  <meta property="og:type" content="website" />
  <style>
    :root{
      --bg:#000;
      --matrix-red:#ff2b2b;
      --panel-bg:rgba(6,6,6,0.94);
      --panel-border:#6b0000;
      --ui-z:9999;
      --font: "Segoe UI", system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif;
    }
    html,body{height:100%;width:100%;margin:0;padding:0;background:var(--bg);overflow:hidden;font-family:var(--font);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; touch-action:manipulation; color:#fff;}
    canvas#c{display:block;width:100%;height:100%;background:var(--bg);}
    /* Admin panel */
    #ui-layer{position:fixed;top:0;left:0;right:0;z-index:var(--ui-z);transform:translateY(-110%);transition:transform .28s ease;background:var(--panel-bg);border-bottom:2px solid var(--panel-border);padding:12px;backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);box-sizing:border-box;}
    body.admin-mode #ui-layer{transform:translateY(0)}
    #ui-row{display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap}
    textarea#msg-input{flex:1 1 580px;min-width:200px;height:100px;resize:none;background:#080808;color:#fff;border:1px solid #222;padding:10px;font-size:13px;border-radius:6px;direction:ltr;text-align:left}
    .controls{display:flex;flex-direction:column;gap:8px}
    button,select,input[type="file"]{background:#0e0e0e;color:#fff;border:1px solid #2b2b2b;padding:10px 12px;border-radius:6px;cursor:pointer;font-weight:700;height:44px}
    button.primary{background:#900;border-color:#600}
    #secret-trigger{position:fixed;bottom:0;left:0;width:50px;height:50px;z-index:10000;background:transparent;touch-action:manipulation}
    #readable-content{position:absolute;left:8px;top:8px;width:calc(100% - 16px);max-height:1px;overflow:hidden;white-space:pre-wrap;opacity:0.3;pointer-events:none;user-select:text;z-index:-10;color:transparent}
    #error-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:10001;pointer-events:none}
    #error-overlay.show{display:flex}
    #loading-indicator{position:fixed;top:12px;left:12px;z-index:10002;display:flex;gap:6px;align-items:center;pointer-events:none}
    .dot{width:8px;height:8px;border-radius:50%;background:#bbb;opacity:.12;animation:dotPulse 1s infinite}
    .dot:nth-child(2){animation-delay:.15s}
    .dot:nth-child(3){animation-delay:.3s}
    @keyframes dotPulse{0%{opacity:.12;transform:translateY(0)}50%{opacity:.9;transform:translateY(-6px)}100%{opacity:.12;transform:translateY(0)}}
    /* small responsive */
    @media (max-width:768px){textarea#msg-input{height:130px;flex-basis:100%}.controls{flex-direction:row;gap:6px}}
    /* visually hidden status for screen readers */
    .sr-only{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
  </style>
</head>
<body>

  <div id="ui-layer" aria-hidden="true">
    <div id="ui-row">
      <textarea id="msg-input" placeholder="البيانات من Gist ستظهر هنا..." aria-label="نص Gist الخام"></textarea>
      <div class="controls" aria-hidden="false">
        <button id="btn-update" class="primary" title="جلب يدوي من RAW">تحديث يدوي من RAW</button>
        <button id="btn-copy-raw" title="نسخ RAW URL">نسخ RAW URL</button>
        <button id="btn-copy-link" title="نسخ رابط الصفحة">نسخ رابط الصفحة</button>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap">
      <label style="display:flex;gap:8px;align-items:center">
        <span style="font-weight:800;color:#ddd">خلفية:</span>
        <select id="bg-select" aria-label="اختيار خلفية">
          <option value="void">Void (أسود)</option>
          <option value="grid">Grid (شبكة)</option>
          <option value="image">Image (صورة)</option>
        </select>
      </label>

      <label style="display:flex;gap:8px;align-items:center">
        <span style="font-weight:800;color:#ddd">رفع صورة:</span>
        <input id="img-uploader" type="file" accept="image/*" aria-label="رفع صورة للخلفية"/>
      </label>

      <button id="btn-clear-image" title="مسح الصورة">مسح الصورة</button>
      <button id="btn-clear-all" title="مسح البيانات المحفوظة">مسح البيانات</button>
    </div>
  </div>

  <div id="readable-content" role="article" aria-live="polite">WAR-CORE SYSTEM INITIALIZING... WAITING FOR GIST PAYLOAD.</div>

  <div id="secret-trigger" role="button" aria-label="مشغّل إدارة سري"></div>

  <canvas id="c" aria-label="عرض WAR-CORE"></canvas>

  <div id="error-overlay" aria-hidden="true"><div style="font-size:32px;font-weight:900;color:var(--matrix-red);text-shadow:0 0 12px rgba(255,0,0,0.5)">CONNECTION LOST</div></div>

  <div id="loading-indicator" aria-hidden="true"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>

  <div class="sr-only" role="status" id="aria-status">جاهز</div>

<script>
/* WAR-CORE V20 - Single-file (Vanilla JS)
   - Implements Blueprint + improvements:
     AbortController + timeout + retry, debounced resize,
     DPR cap, desynchronized ctx fallback, offscreen grid,
     objectURL for images, small-image localStorage, scanlines,
     chromatic aberration, accessibility layer.
*/

/* ---------- Constants & State ---------- */
const RAW_URL = "https://gist.githubusercontent.com/tombad8900/02c19d224a9d2cafc91bf918c81e27a6/raw/";
const FETCH_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes
const FETCH_TIMEOUT_MS = 15 * 1000; // 15 seconds
const MAX_IMAGE_STORE_BYTES = 800_000; // store inline only if smaller (~800KB)
const IMAGE_SIZE_LIMIT_BYTES = 10 * 1024 * 1024; // 10MB absolute limit for upload
const DPR_MAX = 2;

const canvas = document.getElementById('c');
let ctx = null;
let rAFid = null;
let fetchTimerId = null;
let gridCache = null;

const msgInput = document.getElementById('msg-input');
const readableLayer = document.getElementById('readable-content');
const errorOverlay = document.getElementById('error-overlay');
const loadingIndicator = document.getElementById('loading-indicator');
const ariaStatus = document.getElementById('aria-status');

const btnUpdate = document.getElementById('btn-update');
const btnCopyRaw = document.getElementById('btn-copy-raw');
const btnCopyLink = document.getElementById('btn-copy-link');
const imgUploader = document.getElementById('img-uploader');
const bgSelect = document.getElementById('bg-select');
const btnClearImage = document.getElementById('btn-clear-image');
const btnClearAll = document.getElementById('btn-clear-all');
const secretTrigger = document.getElementById('secret-trigger');

let dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);
let w = window.innerWidth, h = window.innerHeight;
let lines = [];
let lastFetchOK = true;
let inFlightFetch = null; // AbortController
let retryCount = 0;
let glitchIntensity = 0;
let gridOffset = 0;
let bgMode = localStorage.getItem('warcore_bg') || 'void';
let uploadedImage = null; // {img:Image, objectUrl, storedDataUrl?}
let imageLoaded = false;
let fetchScheduled = false;
let resizeTimer = null;
let inited = false;

/* ---------- Utility ---------- */
function setStatus(text){
  ariaStatus.textContent = text;
}
function safeTextForMeta(text){
  return (text||'').replace(/[<>]/g,'');
}
function nowMs(){ return (performance && performance.now) ? performance.now() : Date.now(); }

/* ---------- Canvas & DPR ---------- */
function initContext(){
  // try to create desynchronized context with alpha=false; fallback gracefully
  ctx = canvas.getContext('2d', { alpha:false, desynchronized:true }) || canvas.getContext('2d', { alpha:false }) || canvas.getContext('2d');
  ctx.imageSmoothingEnabled = true;
}
function resizeCanvasDebounced(){
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    resizeCanvas();
    rebuildGridCache();
  }, 110);
}
function resizeCanvas(){
  dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);
  w = window.innerWidth;
  h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  if (typeof ctx.setTransform === 'function'){
    ctx.setTransform(dpr,0,0,dpr,0,0);
  } else {
    ctx.scale(dpr, dpr);
  }
}

/* ---------- Offscreen Grid Cache ---------- */
function rebuildGridCache(){
  // create an offscreen canvas sized to CSS pixels (w,h)
  gridCache = document.createElement('canvas');
  gridCache.width = Math.max(1, Math.floor(w));
  gridCache.height = Math.max(1, Math.floor(h));
  const gctx = gridCache.getContext('2d');
  const spacing = Math.max(18, Math.round(Math.min(w,h) * 0.04));
  gctx.clearRect(0,0,gridCache.width,gridCache.height);
  gctx.strokeStyle = 'rgba(0,170,60,0.06)';
  gctx.lineWidth = 1;
  gctx.beginPath();
  for (let x = 0; x < gridCache.width; x += spacing){
    gctx.moveTo(x + 0.5, 0);
    gctx.lineTo(x + 0.5, gridCache.height);
  }
  for (let y = 0; y < gridCache.height; y += spacing){
    gctx.moveTo(0, y + 0.5);
    gctx.lineTo(gridCache.width, y + 0.5);
  }
  gctx.stroke();
  // subtle glow
  const grad = gctx.createRadialGradient(gridCache.width*0.75, gridCache.height*0.25, 0, gridCache.width*0.75, gridCache.height*0.25, Math.max(gridCache.width, gridCache.height));
  grad.addColorStop(0, 'rgba(0,255,120,0.02)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  gctx.fillStyle = grad;
  gctx.fillRect(0,0,gridCache.width,gridCache.height);
}

/* ---------- Fetch with Timeout + Retry ---------- */
async function fetchWithTimeout(url, timeoutMs=FETCH_TIMEOUT_MS, signal=null){
  const controller = new AbortController();
  const combinedSignal = signal ? signal : controller.signal;
  const timer = setTimeout(()=> controller.abort(), timeoutMs);
  try{
    const res = await fetch(url, { cache:'no-store', signal: combinedSignal });
    clearTimeout(timer);
    if (!res.ok) throw new Error('Network response not ok');
    return await res.text();
  } catch(e){
    clearTimeout(timer);
    throw e;
  }
}
async function fetchPayload(manual=false){
  if (inFlightFetch) {
    // avoid overlapping fetches
    setStatus('إلغاء الطلب السابق وإعادة الجلب');
    try { inFlightFetch.abort(); } catch(_) {}
  }
  inFlightFetch = new AbortController();
  loadingIndicator.style.display = 'flex';
  let attempt = 0;
  let lastError = null;
  const maxRetries = 3;
  const baseUrl = `${RAW_URL}?t=${Date.now()}`;
  while (attempt <= maxRetries){
    try{
      setStatus(`جلب البيانات (محاولة ${attempt+1})`);
      const text = await fetchWithTimeout(baseUrl, FETCH_TIMEOUT_MS, inFlightFetch.signal);
      applyPayload(text);
      lastFetchOK = true;
      errorOverlay.classList.remove('show');
      setStatus('تم جلب البيانات بنجاح');
      retryCount = 0;
      loadingIndicator.style.display = 'none';
      inFlightFetch = null;
      return;
    } catch(err){
      lastError = err;
      attempt++;
      retryCount++;
      setStatus(`خطأ في الاتصال (${attempt})`);
      // backoff
      await new Promise(res => setTimeout(res, 500 * attempt));
      if (inFlightFetch.signal.aborted) break;
    }
  }
  // failed
  lastFetchOK = false;
  readableLayer.innerText = "ERROR: CONNECTION LOST TO MAIN FRAME.";
  errorOverlay.classList.add('show');
  loadingIndicator.style.display = 'none';
  inFlightFetch = null;
  setStatus('فشل في جلب البيانات بعد عدة محاولات');
  // keep previous lines if any, otherwise show CONNECTION LOST
  if (!Array.isArray(lines) || lines.length === 0) lines = ["CONNECTION LOST"];
}

/* ---------- Apply Payload ---------- */
function applyPayload(text){
  text = text || '';
  // sanitize minimal
  const safe = safeTextForMeta(text);
  readableLayer.innerText = text;
  lines = text.split('\n').filter(l => l.trim().length > 0);
  document.getElementById('meta-desc')?.setAttribute('content', safe.substring(0,150));
  document.getElementById('og-desc')?.setAttribute('content', safe.substring(0,200));
  document.title = "MATRIX: " + (lines[0] || 'Active');
  glitchIntensity = 18;
}

/* ---------- Image Upload Handling ---------- */
function revokeImageObjectUrl(obj){
  try{ if (obj && obj.objectUrl) URL.revokeObjectURL(obj.objectUrl); } catch(e){}
}
function clearUploadedImage(removeStored=false){
  if (uploadedImage){
    revokeImageObjectUrl(uploadedImage);
  }
  uploadedImage = null;
  imageLoaded = false;
  if (removeStored) {
    localStorage.removeItem('warcore_image_data');
    localStorage.removeItem('warcore_image_meta');
  }
}
imgUploader.addEventListener('change', async (ev) => {
  const file = ev.target.files && ev.target.files[0];
  if (!file) return;
  if (file.size > IMAGE_SIZE_LIMIT_BYTES){
    alert('حجم الصورة أكبر من الحد المسموح (10MB).');
    return;
  }
  // basic type check
  if (!file.type.startsWith('image/')){
    alert('الملف ليس صورة صالحة.');
    return;
  }
  // create object URL for immediate display; store small images in localStorage
  const objUrl = URL.createObjectURL(file);
  const img = new Image();
  img.onload = () => {
    revokeImageObjectUrl(uploadedImage); // revoke previous if any
    uploadedImage = { img, objectUrl: objUrl, storedDataUrl: null };
    imageLoaded = true;
    bgMode = 'image';
    bgSelect.value = 'image';
    setStatus('تم رفع الصورة');
    // store if small
    if (file.size <= MAX_IMAGE_STORE_BYTES){
      // read as dataURL
      const fr = new FileReader();
      fr.onload = function(e){
        try {
          localStorage.setItem('warcore_image_data', e.target.result);
          localStorage.setItem('warcore_image_meta', JSON.stringify({name:file.name,size:file.size,type:file.type,t:Date.now()}));
        } catch(err){
          console.warn('failed to store image in localStorage', err);
        }
      };
      fr.readAsDataURL(file);
    } else {
      // ensure not stored
      localStorage.removeItem('warcore_image_data');
      localStorage.removeItem('warcore_image_meta');
    }
  };
  img.onerror = () => {
    URL.revokeObjectURL(objUrl);
    alert('فشل تحميل الصورة.');
    setStatus('خطأ عند تحميل الصورة');
  };
  img.src = objUrl;
});

/* ---------- Restore Stored Preferences ---------- */
function restorePreferences(){
  try{
    const storedBg = localStorage.getItem('warcore_bg');
    if (storedBg) { bgMode = storedBg; bgSelect.value = storedBg; }
    const storedText = localStorage.getItem('warcore_text');
    if (storedText) msgInput.value = storedText;
    const imgData = localStorage.getItem('warcore_image_data');
    if (imgData){
      const img = new Image();
      img.onload = () => {
        uploadedImage = { img, objectUrl:null, storedDataUrl: imgData };
        imageLoaded = true;
        bgMode = 'image';
        bgSelect.value = 'image';
      };
      img.onerror = () => {
        localStorage.removeItem('warcore_image_data');
        localStorage.removeItem('warcore_image_meta');
      };
      img.src = imgData;
    }
  } catch(e){ console.warn('restorePreferences failed', e); }
}

/* ---------- Copy helpers ---------- */
function flashCopy(button, text){
  navigator.clipboard?.writeText(text).then(()=>{
    const prev = button.textContent;
    button.textContent = '✓ تم النسخ';
    setTimeout(()=> button.textContent = prev, 1400);
  }).catch(()=> alert('فشل النسخ'));
}

/* ---------- Draw Routines ---------- */
function drawBackground(){
  if (bgMode === 'void'){
    // nothing (canvas cleared)
  } else if (bgMode === 'grid'){
    // draw gridCache with offset
    if (gridCache){
      // tile draw for smooth movement
      const ox = Math.floor(gridOffset % gridCache.width);
      ctx.save();
      ctx.globalAlpha = 1;
      // draw two tiles horizontally/vertically to cover shifts
      for (let sx = -gridCache.width; sx <= w + gridCache.width; sx += gridCache.width){
        for (let sy = -gridCache.height; sy <= h + gridCache.height; sy += gridCache.height){
          ctx.drawImage(gridCache, sx - ox, sy);
        }
      }
      ctx.restore();
    }
  } else if (bgMode === 'image' && uploadedImage && imageLoaded){
    // cover fit with filters
    const img = uploadedImage.img;
    const iw = img.width, ih = img.height;
    if (iw>0 && ih>0){
      const scale = Math.max(w/iw, h/ih);
      const dw = iw * scale, dh = ih * scale;
      const dx = (w - dw)/2, dy = (h - dh)/2;
      ctx.save();
      // filter: grayscale(100%) contrast(120%) brightness(60%)
      ctx.filter = 'grayscale(100%) contrast(120%) brightness(60%)';
      // draw using CSS pixel coords; canvas internal already scaled via setTransform
      ctx.drawImage(img, dx, dy, dw, dh);
      ctx.filter = 'none';
      ctx.restore();
    }
  }
}
function drawScanlines(){
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  for (let y=0;y<h;y+=4){
    ctx.fillRect(0,y,w,1);
  }
  ctx.restore();
}
function drawNoise(){
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i=0;i<5;i++){
    ctx.fillStyle = `rgba(255,255,255,${(Math.random()*0.03+0.01).toFixed(3)})`;
    ctx.fillRect(Math.random()*w, Math.random()*h, 1+Math.random()*2,1+Math.random()*2);
  }
  ctx.restore();
}
function drawText(){
  if (!Array.isArray(lines) || lines.length===0) return;
  // Font sizing
  // Start with candidate
  let fs = Math.min(w * 0.12, (h * 0.8) / (lines.length * 1.2));
  ctx.font = `900 ${Math.floor(fs)}px ${getComputedStyle(document.body).fontFamily}`;
  // measure widest
  let widest = 0;
  lines.forEach(l =>{ widest = Math.max(widest, ctx.measureText(l).width); });
  if (widest > w * 0.9){
    fs = fs * (w * 0.9 / widest);
  }
  fs = Math.max(10, Math.floor(fs));
  ctx.font = `900 ${fs}px ${getComputedStyle(document.body).fontFamily}`;
  const lh = fs * 1.2;
  const totalH = lines.length * lh;
  // Centering formula recommended:
  const startY = (h / 2) - (totalH / 2) + (lh / 2);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  lines.forEach((line,i)=>{
    const y = startY + (i * lh);
    const x = w/2;
    // chromatic aberration
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const shift = Math.max(1, Math.round(fs * 0.015));
    ctx.fillStyle = 'rgba(255,0,0,0.8)';
    ctx.fillText(line, x - shift, y);
    ctx.fillStyle = 'rgba(0,255,255,0.8)';
    ctx.fillText(line, x + shift, y);
    ctx.restore();
    // main white with stroke shield
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineWidth = Math.max(1, fs * 0.06);
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#fff';
    ctx.lineJoin = 'round';
    ctx.miterLimit = 2;
    ctx.strokeText(line, x, y);
    ctx.fillText(line, x, y);
    ctx.restore();
  });
}

/* ---------- Main Render Loop ---------- */
let lastTime = nowMs();
function renderLoop(ts){
  const now = ts || performance.now();
  const dt = now - lastTime;
  lastTime = now;
  // decay glitch
  glitchIntensity = Math.max(0, glitchIntensity * 0.92 - 0.01);
  gridOffset += dt * 0.02;

  // clear (CSS pixels)
  ctx.save();
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,w,h);
  ctx.restore();

  drawBackground();
  drawScanlines();

  if (!lastFetchOK){
    // big CONNECTION LOST
    ctx.save();
    const msg = "CONNECTION LOST";
    const fs = Math.min(w * 0.12, h * 0.18);
    ctx.font = `900 ${Math.floor(fs)}px ${getComputedStyle(document.body).fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const alpha = 0.6 + 0.4 * Math.abs(Math.sin(now/400));
    ctx.fillStyle = `rgba(255,20,20,${alpha})`;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = Math.max(2, fs * 0.06);
    ctx.strokeText(msg, w/2, h/2);
    ctx.fillText(msg, w/2, h/2);
    ctx.restore();
  } else {
    drawText();
  }

  drawNoise();

  rAFid = requestAnimationFrame(renderLoop);
}

/* ---------- Event Listeners & Controls ---------- */
btnUpdate.addEventListener('click', ()=> fetchPayload(true));
btnCopyRaw.addEventListener('click', function(){ flashCopy(this, RAW_URL); });
btnCopyLink.addEventListener('click', function(){ flashCopy(this, window.location.href); });
btnClearImage.addEventListener('click', ()=> { if (confirm('مسح الصورة المرفوعة؟')) { clearUploadedImage(true); }});
btnClearAll.addEventListener('click', ()=> {
  if (!confirm('هل تريد مسح كل البيانات المحفوظة (الخلفية، الصورة، النص)؟')) return;
  try {
    localStorage.removeItem('warcore_bg');
    localStorage.removeItem('warcore_text');
    localStorage.removeItem('warcore_image_data');
    localStorage.removeItem('warcore_image_meta');
  } catch(e){}
  clearUploadedImage(true);
  msgInput.value = '';
  bgMode = 'void';
  bgSelect.value = 'void';
  setStatus('تم مسح البيانات');
});

bgSelect.addEventListener('change', (e)=> {
  bgMode = e.target.value;
  try{ localStorage.setItem('warcore_bg', bgMode); } catch(e){}
});

msgInput.addEventListener('input', (e)=> {
  try{ localStorage.setItem('warcore_text', e.target.value); } catch(e){}
});

// secret trigger toggles admin
secretTrigger.addEventListener('click', ()=> {
  document.body.classList.toggle('admin-mode');
  const isAdmin = document.body.classList.contains('admin-mode');
  document.getElementById('ui-layer').setAttribute('aria-hidden', (!isAdmin).toString());
});

// keyboard shortcut Ctrl+Shift+A
document.addEventListener('keydown', (ev)=>{
  if (ev.ctrlKey && ev.shiftKey && (ev.key==='A' || ev.key==='a')) {
    ev.preventDefault();
    document.body.classList.toggle('admin-mode');
    const isAdmin = document.body.classList.contains('admin-mode');
    document.getElementById('ui-layer').setAttribute('aria-hidden', (!isAdmin).toString());
  }
});

window.addEventListener('resize', resizeCanvasDebounced);

/* ---------- Lifecycle & Init ---------- */
function start(){
  if (inited) return;
  inited = true;
  initContext();
  resizeCanvas();
  rebuildGridCache();
  restorePreferences();
  // initial fetch and schedule
  fetchPayload(false);
  fetchTimerId = setInterval(()=> fetchPayload(false), FETCH_INTERVAL_MS);
  // start render
  rAFid = requestAnimationFrame(renderLoop);
  // show loading briefly
  loadingIndicator.style.display = 'none';
  setStatus('جاهز');
}
function stop(){
  try{ if (inFlightFetch) inFlightFetch.abort(); } catch(e){}
  if (rAFid) cancelAnimationFrame(rAFid);
  if (fetchTimerId) clearInterval(fetchTimerId);
  revokeImageObjectUrl(uploadedImage);
}
window.addEventListener('beforeunload', stop);
start();

/* ---------- Expose small API for debugging ---------- */
window.WARCORE = {
  fetchPayload,
  setBackground(mode){ if (['void','grid','image'].includes(mode)){ bgMode=mode; bgSelect.value=mode; try{ localStorage.setItem('warcore_bg', bgMode);}catch(e){} } },
  clearImage: ()=> clearUploadedImage(true),
  getState: ()=> ({bgMode, imageLoaded, lastFetchOK, linesCount: lines.length})
};
</script>
</body>
</html>